\documentclass[autodetect-engine,dvi=dvipdfmx,ja=standard,
               a4j,11pt]{bxjsarticle}

\RequirePackage{geometry}
\geometry{reset,paperwidth=210truemm,paperheight=297truemm}
\geometry{hmargin=.75truein,top=20truemm,bottom=25truemm,footskip=10truemm,headheight=0mm}
%\geometry{showframe} % 本文の"枠"を確認したければ，コメントアウト
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{spverbatim}
\renewcommand{\theFancyVerbLine}{\texttt{\footnotesize{\arabic{FancyVerbLine}:}}}

\title{コンパイラ実験}

\author{学生番号: 09B54923549\\
        中嶋 空偉 (NAKAJIMA, Sorai)}
\date{\number\year 年\number\month 月\number\day 日}

%%======== 本文 ====================================================%%
\begin{document}
\maketitle
% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}

%--------------------------------------------------------------------%
\section{実験の概要と目的} \label{sec:abstract}
\subsection{本実験の概要}
この実験では，独自に定義した言語をソース言語として，アセンブリ言語を
目的言語として変換するコンパイラを作成する．
コンパイラ作成の際には，字句解析を行うプログラムを生成するものとしてflex，構文解析を行うプログラムを生成するものとしてbison，astとコード生成に関してはc言語でプログラムを作成する．

\subsection{本実験の目的}
3年間の総仕上げとしてある程度大きなプログラムを作成する．
仕様を決め，プログラムを書き，データ構造を決め，アルゴリズムを考え，テストパターンを決め，デバッグするなどの一連の流れを経験する．


\section{言語の定義}

本コンパイラが受理する言語の文法定義を以下に示す．
これはBisonの構文規則からC言語アクションコードを取り除いたものである．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\footnotesize, baselinestretch=0.9]
program
    : declarations statements
;

declarations
    : decl_statement declarations
    | decl_statement
;

decl_statement
    : DEFINE IDENT SEMIC
    | ARRAY IDENT L_BRACKET NUMBER R_BRACKET SEMIC
    | ARRAY IDENT L_BRACKET NUMBER R_BRACKET L_BRACKET NUMBER R_BRACKET SEMIC
;

statements
    : statement statements
    | statement
;

statement
    : assignment_stmt
    | loop_stmt
    | cond_stmt
    | expression SEMIC
;

assignment_stmt
    : IDENT ASSIGN expression SEMIC
    | IDENT L_BRACKET expression R_BRACKET ASSIGN expression SEMIC
    | IDENT L_BRACKET expression R_BRACKET L_BRACKET expression R_BRACKET ASSIGN expression SEMIC
;

expression
    : expression add_op term
    | term
;

term
    : term mul_op factor
    | factor
;

factor
    : var
    | NUMBER
    | L_PAREN expression R_PAREN
    | IDENT L_BRACKET expression R_BRACKET
    | IDENT L_BRACKET expression R_BRACKET L_BRACKET expression R_BRACKET
;

add_op
    : PLUS
    | MINUS
;

mul_op
    : MUL
    | DIV
;

var
    : IDENT
;

loop_stmt
    : WHILE L_PAREN condition R_PAREN L_BRACE statements R_BRACE
;

cond_stmt
    : IF L_PAREN condition R_PAREN L_BRACE statements R_BRACE ELSE L_BRACE statements R_BRACE
    | IF L_PAREN condition R_PAREN L_BRACE statements R_BRACE
;

condition
    : expression cond_op expression
;

cond_op
    : EQ
    | NE
    | LE
    | GE
    | LT
    | GT
;
\end{Verbatim}

\section{受理されるプログラム例}

本コンパイラで受理できるプログラムの例を示す．

\subsection{基本演算とWhileループ}

まず，基本的な演算と繰り返し処理の例として，1から10までの和を計算するプログラムを示す．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.9]
define i;
define sum;
sum = 0;
i = 1;
while (i < 11) {
  sum = sum + i;
  i = i + 1;
}
sum;
\end{Verbatim}

このプログラムでは，変数\verb|i|を1から10まで1ずつ増やしながら，\verb|sum|に加算していくことで和を求めている．

\subsection{条件分岐 (If-Else)}

次に，条件分岐の例として，2つの数値の大小比較を行い，大きい方から小さい方を減算するプログラムを示す．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.9]
define a;
define b;
a = 10;
b = 5;
if (a > b) {
  a = a - b;
} else {
  a = a + b;
}
a;
\end{Verbatim}

このプログラムでは，\verb|if-else|文を使用して条件によって実行する処理を分岐している．本コンパイラでは，\verb|==|，\verb|!=|，\verb|<=|，\verb|>=|，\verb|<|，\verb|>|の比較演算子が利用可能である．

\subsection{配列の使用}

最後に，配列の例として，3行3列の2次元配列の対角成分の和を計算するプログラムを示す．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.9]
array arr[3][3];
define sum;
define i;
arr[0][0] = 1;
arr[0][1] = 2;
arr[0][2] = 3;
arr[1][0] = 4;
arr[1][1] = 5;
arr[1][2] = 6;
arr[2][0] = 7;
arr[2][1] = 8;
arr[2][2] = 9;
sum = 0;
i = 0;
while (i < 3) {
  sum = sum + arr[i][i];
  i = i + 1;
}
sum;
\end{Verbatim}

このプログラムでは，2次元配列を宣言し，対角成分（\verb|arr[0][0]|，\verb|arr[1][1]|，\verb|arr[2][2]|）を\verb|while|ループを用いて順に足し合わせている．1次元配列と2次元配列の両方がサポートされている．

\section{コード生成の実装}

本章では，コンパイラの核心部分であるコード生成の実装詳細について述べる．
本実験では，MIPSアーキテクチャ上で動作するアセンブリコードを出力することを目的とした．
実装にあたり，レジスタ割り当ての複雑さを回避し，実装の確実性を優先するため，演算の途中経過を逐一スタックに退避する「スタックマシン」方式を採用した．

\subsection{算術式のコード生成}
算術式の計算においては，以下のルールに従ってコード生成を行った．
\begin{itemize}
  \item 演算の結果は常に \texttt{\$v0} レジスタに格納する．
  \item 演算の対象となるもう一方の値は，スタックから \texttt{\$v1} レジスタに復帰させる．
  \item 演算終了後，必要に応じて結果を再度スタックにプッシュ（退避）する．
\end{itemize}

具体的には，\texttt{PLUS\_AST}（加算）などの二項演算において，以下の手順で処理を行っている．
\begin{enumerate}
  \item 右辺の子ノードを再帰的に評価し，結果（\texttt{\$v0}）をスタックにプッシュ（退避）する．
  \item 左辺の子ノードを再帰的に評価し，結果を \texttt{\$v0} に得る．
  \item スタックから退避していた右辺の値を \texttt{\$v1} にポップ（復帰）させる．
  \item \texttt{add \$v0, \$v0, \$v1} 命令を発行する．
\end{enumerate}

特に工夫した点として，右辺から先に評価する順序を採用したことが挙げられる．
これにより，減算（\texttt{sub}）のような非可換な演算においても，
スタックから取り出した値（右辺）が自然に第2オペランド（引く数）となり，
\texttt{sub \$v0, \$v0(左), \$v1(右)} という直感的な命令生成が可能となった．

\subsection{制御構文の翻訳}
\texttt{while} 文や \texttt{if} 文の実装では，ジャンプ先のラベル生成が課題となった．
単純な固定ラベルではネスト構造に対応できないため，\texttt{while\_loop\_count} などの静的カウンタ変数を導入した．
これにより，\texttt{\$WHILE\_LOOP\_START\_0}，\texttt{\$WHILE\_LOOP\_START\_1} のようにユニークなラベルを生成し，
多重ループや複雑な分岐構造でも正しく動作するように実装した．

また，条件判定においては C言語の「0ならば偽，それ以外は真」という仕様に基づき，
条件式の結果が0（偽）の場合に処理をスキップ（分岐）させるため，
MIPSの \texttt{beq \$v0, \$zero, LABEL} 命令を用いて表現した．
さらに，MIPS特有の遅延分岐（Delay Slot）に対しては，分岐命令の直後に必ず \texttt{nop} を挿入することで，
意図しない命令実行を防ぐ安全な実装とした．

\subsection{変数と配列のメモリ管理}
変数のアクセスには，関数実行中に変動するスタックポインタ（\texttt{\$sp}）ではなく，
フレームポインタ（\texttt{\$fp}）を基準としたオフセット方式（例：\texttt{lw \$v0, -4(\$fp)}）を採用した．

特に2次元配列（\texttt{array[i][j]}）の実装では，行優先（Row-Major）配置を前提とし，
シンボルテーブルに配列の列数（cols）を記録する設計とした．
アクセス時には，$ \texttt{address} = \texttt{base} + (i \times \texttt{cols} + j) \times 4 $ という計算式をアセンブリ命令として展開し，
動的なインデックスに対しても正しいアドレス計算を実現している．

\section{特に工夫した点}

\subsection{2パス処理によるメモリ領域管理}
本コンパイラの実装において最も工夫し，苦労した点は変数のメモリ管理である．
MIPSの関数呼び出し規約では，関数の先頭で必要なスタック領域を一括して確保することが望ましい．
しかし，C言語では関数の途中でも変数宣言が可能であるため，単純な1パスのコンパイラでは，
コード生成開始時に正確なフレームサイズを知ることができないという問題に直面した．

そこで本実装では，コード生成関数 \texttt{generate\_code} において，以下の2段階（2パス）の処理を行う設計とした．

\begin{enumerate}
  \item \textbf{第1パス（宣言解析）}: AST全体を一度走査（\texttt{find\_declarations}）し，全ての変数宣言を検出してシンボルテーブルに登録する．同時に各変数のスタックフレーム上のオフセットアドレスを決定し，必要な変数の総サイズを確定させる．これにより第2パスでのアドレス計算処理が不要となる．
  \item \textbf{第2パス（コード生成）}: 確定したサイズ情報を元にスタック確保命令（\texttt{addiu \$sp, \$sp, -size}）を出力し，その後に実際のAST走査を行う．
\end{enumerate}

最初は変数が見つかるたびにスタックを拡張する方法も考えたが，オフセット計算が複雑になりバグの原因となったため，
この「静的領域を先に確定させる」方式に切り替えた．
結果として，メモリ管理が非常にシンプルかつ堅牢になり，バグを大幅に減らすことができた．

\subsection{コンパイラのソースプログラム}

本コンパイラのソースコードは以下のディレクトリに配置されている．

\begin{Verbatim}[fontsize=\small]
c-compiler/
├── src/
│   ├── codegen.c        # コード生成
│   ├── program.y        # Bison構文規則
│   ├── program.l        # Flex字句規則
│   ├── symbol_table.c   # シンボルテーブル
│   └── ...
└── Makefile
\end{Verbatim}

\section{最終課題のプログラムと実行結果}

\subsection{1から10までの数の和}

\subsubsection{プログラム}

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.8]
define i;
define sum;
sum = 0;
i = 1;
while(i < 11) {
  sum = sum + i;
  i = i + 1;
}
\end{Verbatim}


\subsubsection{実行結果}

シミュレータによる実行結果（主要部分）を以下に示す．

\begin{Verbatim}[fontsize=\footnotesize]
*** total inst. count:          347
*** total cycle count:         1421
***               IPC:   0.244 (inst/cycle)
***               CPI:   4.095 (cycle/inst)
\end{Verbatim}
\begin{Verbatim}[fontsize=\footnotesize]
7fffffe0: 0000000b 00000000 00000000 00000037
7ffffff0: 0000000b 00000000 00000018 00000000
\end{Verbatim}

メモリダンプより，\texttt{sum} はアドレス \texttt{0x7fffffec} に格納され，値は \textbf{0x37}（10進数で \textbf{55}）であることが確認できる．
これは $1 + 2 + \cdots + 10 = 55$ という正しい計算結果と一致している．

\subsection{5の階乗}

\subsubsection{プログラム}

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.8]
define i;
define fact;

fact = 1;
i = 1;
while(i < 6) {
  fact = fact * i;
  i = i + 1;
}
fact;
\end{Verbatim}

\subsubsection{実行結果}

シミュレータによる実行結果（主要部分）を以下に示す．

\begin{Verbatim}[fontsize=\footnotesize]
*** total inst. count:          197
*** total cycle count:          806
***               IPC:   0.244 (inst/cycle)
***               CPI:   4.091 (cycle/inst)
\end{Verbatim}
\begin{Verbatim}[fontsize=\footnotesize]
7fffffe0: 00000006 00000000 00000000 00000078
7ffffff0: 00000006 00000000 00000018 00000000
\end{Verbatim}

メモリダンプより，\texttt{fact} はアドレス \texttt{0x7fffffec} に格納され，値は \textbf{0x78}（10進数で \textbf{120}）であることが確認できる．
これは $1 \times 2 \times 3 \times 4 \times 5 = 120$ という正しい計算結果と一致している．

\subsection{FizzBuzz}

\subsubsection{プログラム}

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.8]
define fizz;
define buzz;
define fizzbuzz;
define others;
define i;
fizz = 0;
buzz = 0;
fizzbuzz = 0;
others = 0;
i = 1;
while(i < 31) {
  if((i / 15) * 15 == i) {
    fizzbuzz = fizzbuzz + 1;
  } else {
    if((i / 3) * 3 == i) {
      fizz = fizz + 1;
    } else {
      if((i / 5) * 5 == i) {
        buzz = buzz + 1;
      } else {
        others = others + 1;
      }
    }
  }
  i = i + 1;
}
others;
\end{Verbatim}

\subsubsection{実行結果}

シミュレータによる実行結果（主要部分）を以下に示す．

\begin{Verbatim}[fontsize=\footnotesize]
*** total inst. count:         3077
*** total cycle count:        12577
***               IPC:   0.245 (inst/cycle)
***               CPI:   4.087 (cycle/inst)
\end{Verbatim}
\begin{Verbatim}[fontsize=\footnotesize]
7fffffc0: 00000000 00000000 00000000 0000000f
7fffffd0: 0000000f 0000001f 00000000 00000000
7fffffe0: 0000001f 00000010 00000002 00000004
7ffffff0: 00000008 00000000 00000018 00000000
\end{Verbatim}

メモリダンプより，各カウンタの値を確認できる．
\texttt{fizzbuzz}（3 と 5 両方で割り切れる）は \textbf{0x02}（2個），\texttt{fizz}（3 で割り切れる）は \textbf{0x08}（8個），
\texttt{buzz}（5 で割り切れる）は \textbf{0x04}（4個），\texttt{others}（いずれでも割り切れない）は \textbf{0x10}（16個）となっていることが読み取れる．
プログラムの最後で \texttt{others} の値 \textbf{0x10}（16個）が出力されており，
$2 + 8 + 4 + 16 = 30$ となり，ループ回数と一致しているため正しい実行結果であると言える．


\subsection{エラトステネス}

\subsubsection{プログラム}

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.8]
define N;
define i;
define j;
define k;
array a[1001];
N = 1000;
i = 1;
while (i <= N) {
  a[i] = 1;
  i = i + 1;
}
i = 2;
while( i <= N/2) {
  j = 2;
  while(j <= N/i){
    k = i * j;
    a[k] = 0;
    j = j + 1;
  }
  i = i + 1;
}
\end{Verbatim}


\subsubsection{実行結果}

シミュレータによる実行結果（主要部分）を以下に示す．

\begin{Verbatim}[fontsize=\footnotesize]
*** total inst. count:       335792
*** total cycle count:      1389229
***               IPC:   0.242 (inst/cycle)
***               CPI:   4.137 (cycle/inst)
\end{Verbatim}
\begin{Verbatim}[fontsize=\footnotesize]
7ffff030: 00000000 000001f4 00000000 00000000
7ffff040: 00000000 00000001 00000001 00000001
7ffff050: 00000000 00000001 00000000 00000001
7ffff060: 00000000 00000000 00000000 00000001
7ffff070: 00000000 00000001 00000000 00000000
7ffff080: 00000000 00000001 00000000 00000001
7ffff090: 00000000 00000000 00000000 00000001
7ffff0b0: 00000000 00000001 00000000 00000001
\end{Verbatim}

メモリダンプより，配列 \texttt{a} の素数フラグを確認できる．
最初の行には \texttt{N} = \textbf{0x1f4}（1000）が格納されている．
配列 \texttt{a[1]} 〜 \texttt{a[16]} の値を見ると，
\texttt{1}（素数フラグ）の位置は \texttt{a[2]}，\texttt{a[3]}，\texttt{a[5]}，\texttt{a[7]}，\texttt{a[11]}，\texttt{a[13]} であり，
これは実際に素数である 2, 3, 5, 7, 11, 13 に対応していることが確認できる．
エラトステネスの篩アルゴリズムが正しく実装されていることが分かる．


\subsection{二次元配列}

\subsubsection{プログラム}

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
                 fontsize=\small, baselinestretch=0.8]
array matrix1[2][2];
array matrix2[2][2];
array matrix3[2][2];
define i;
define j;
define k;
matrix1[0][0] = 1;
matrix1[0][1] = 2;
matrix1[1][0] = 3;
matrix1[1][1] = 4;
matrix2[0][0] = 5;
matrix2[0][1] = 6;
matrix2[1][0] = 7;
matrix2[1][1] = 8;
i=0;
while(i<2){
    j=0;
    while(j<2){
        matrix3[i][j] = 0;
        j = j+1;
    }
    i = i+1;
}
i=0;
while(i<2){
    j=0;
    while(j<2){
        k=0;
        while(k<2){
            matrix3[i][j] = matrix3[i][j] + matrix1[i][k] * matrix2[k][j];
            k = k+1;
        }
        j = j+1;
    }
    i = i +1;
}
\end{Verbatim}


\subsubsection{実行結果}

シミュレータによる実行結果（主要部分）を以下に示す．

\begin{Verbatim}[fontsize=\footnotesize]
*** total inst. count:         1365
*** total cycle count:         5594
***               IPC:   0.244 (inst/cycle)
***               CPI:   4.098 (cycle/inst)
\end{Verbatim}
\begin{Verbatim}[fontsize=\footnotesize]
7fffffa0: 00000000 00000000 00000000 00000002
7fffffb0: 00000000 00000000 00000002 00000002
7fffffc0: 00000002 00000013 00000016 0000002b
7fffffd0: 00000032 00000005 00000006 00000007
7fffffe0: 00000008 00000001 00000002 00000003
7ffffff0: 00000004 00000000 00000018 00000000
\end{Verbatim}

メモリダンプより，行列 \texttt{matrix3} の計算結果を確認できる．
\texttt{matrix3[0][0]} = \textbf{0x13}（19），\texttt{matrix3[0][1]} = \textbf{0x16}（22），
\texttt{matrix3[1][0]} = \textbf{0x2b}（43），\texttt{matrix3[1][1]} = \textbf{0x32}（50）となっている．
これらは以下の行列積の計算結果と正しく一致している．
\[
\left[
\begin{array}{cc}
1 & 2 \\
3 & 4
\end{array}
\right]
\times
\left[
\begin{array}{cc}
5 & 6 \\
7 & 8
\end{array}
\right]
=
\left[
\begin{array}{cc}
1 \times 5 + 2 \times 7 & 1 \times 6 + 2 \times 8 \\
3 \times 5 + 4 \times 7 & 3 \times 6 + 4 \times 8
\end{array}
\right]
=
\left[
\begin{array}{cc}
19 & 22 \\
43 & 50
\end{array}
\right]
\]


\section{考察}

本実験におけるコード生成の実装と性能，そしてその工夫点について，定量的なデータと実験を用いて以下の通り考察する．

\subsection{スタックマシン方式の評価と課題}

\subsubsection{メモリアクセス頻度の分析}
本コンパイラは，演算の途中経過や変数の値を逐一スタックに退避する「スタックマシン」方式を採用している．この方式のオーバーヘッドを評価するため，「1から10までの和」を計算するプログラム（\verb|sum.c|）の生成コード（\verb|output/sum.s|）を分析した．

\paragraph{データ分析}
総命令数 70 行（静的ステップ数）のうち，\verb|sw|（ストア）および \verb|lw|（ロード）命令は合計 19 行であり，全命令の約 \textbf{27\%} がメモリアクセス命令で占められていることが判明した．
一般的な RISC アーキテクチャ（MIPS 含む）において，メモリアクセスはレジスタ間演算に比べてレイテンシが大きく，パイプラインハザードの原因にもなりやすい．命令数の約3割がメモリアクセスであるという事実は，実行性能において看過できないボトルネックとなっている．

\paragraph{実験による考察}
この高いメモリアクセス頻度は，主に（1）レジスタ割り当ての複雑さを回避する設計，（2）演算のたびにスタックへのアクセスを強制する実装，の 2 つに起因していると考えられる．
特にループ内の変数アクセス（例：\verb|lw \$v0, -12(\$fp)| → 計算 → \verb|sw \$v0, -16(\$fp)|）が毎回繰り返されているため，ループ全体の実行時間に支配的な影響を与えているのが見逃せない．

\subsection{レジスタ割り当てによる最適化の実験}

スタックマシン方式の課題を実証するため，\verb|codegen.c| を一時的に改造し，特定の変数（\verb|i| と \verb|sum|）を強制的にレジスタ（\verb|$t0|，\verb|$t1|）に割り当てる「ハードコード最適化」実験を行った．
この最適化を行ったコンパイラで \verb|sum.c| を再コンパイルした結果，表\ref{tab:optimization_result} に示す改善が見られた．

\begin{table}[htb]
  \centering
  \caption{スタックマシン方式とレジスタ割り当て（手動最適化）の性能比較}
  \label{tab:optimization_result}
  \begin{tabular}{|l|c|c|c|} \hline
    \textbf{評価項目} & \textbf{オリジナル (Stack)} & \textbf{最適化実験版 (Reg)} & \textbf{改善率} \\ \hline \hline
    実行サイクル数 & 347 cycles & 305 cycles & 約 12\% 減 \\ \hline
    \texttt{sw} 命令実行回数 & 19 回 & 5 回 & 約 74\% 減 \\ \hline
    実行結果 & 55 (正解) & 55 (正解) & - \\ \hline
  \end{tabular}
\end{table}

\paragraph{分析}
\begin{itemize}
  \item 変数の読み書きをレジスタ化しただけで，ストア命令の実行回数は劇的に減少し，プログラム全体の実行ステップ数も1割以上削減された．
  \item 今回は演算の途中経過（プッシュ/ポップ）までは最適化していないため，もしそれらも含めてフルにレジスタを利用すれば，さらに大幅な性能向上が見込める．
  \item この実験より，実用的なコンパイラにおいては，スタックマシン方式から脱却し，グラフ彩色アルゴリズム等を用いた適切なレジスタ割り当て（Register Allocation）を実装することが不可欠であると結論付けられる．
\end{itemize}

\subsection{AST設計と拡張性}

\subsubsection{2次元配列の実装とAST}
本実験において，2次元配列（\verb|array[i][j]|）の実装がスムーズに進んだ要因は，構文解析（Parser）段階でのAST設計にある．
\verb|ARRAY_DECL_STATEMENT_AST| ノードに配列の次元情報（行数・列数）を保持させる設計としたことで，コード生成フェーズにおいてシンボルテーブルに必要な情報（\verb|cols|）を確実に渡すことができた．
もしASTに必要な情報が含まれていなければ，コード生成中に情報を補完する複雑な処理（バックパッチなど）が必要となり，実装難易度は格段に上がっていたはずである．「後のフェーズで必要となる情報は，全てASTに残す」という原則の重要性を再認識した．

\subsection{MIPSアーキテクチャへの適応}

\subsubsection{遅延分岐スロットの対処}
MIPS特有の遅延分岐（Delay Slot）に対し，本実装では一律 \verb|nop| を挿入する安全策をとった．
\verb|FizzBuzz| プログラムの実行結果（3,077命令）を見ると，その相当数が \verb|nop| であると推測される．
商用コンパイラでは，このスロットに「分岐の直前の命令」や「分岐先でも分岐しなくても無害な命令」を移動させる「遅延スロット・スケジューリング」が行われる．
本コンパイラでも，単純な \verb|nop| 挿入ではなく，直前の計算命令をスロットに移動させる最適化を実装すれば，命令数をさらに数\%〜10\%程度削減できる余地があると考えられる．

% \begin{thebibliography}{99}
%  \bibitem{book:algodata} 平田富雄，アルゴリズムとデータ構造，森北出版，1990.
%  \bibitem{book:label2} 著者名，書名，出版社，発行年.
%  \bibitem{www:label3} WWWページタイトル，\spverb!https://example.of.too.long.url.jp/you.must.use.spverb/and.insert. a.space.somewhere.to.avoid.overfull.html!，アクセス日.
% \end{thebibliography}
%
%--------------------------------------------------------------------%
\end{document}
