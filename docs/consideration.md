# 第5章 考察

本章では，実験結果を踏まえ，本コンパイラの設計方針が性能や実装に与えた影響について，定量的なデータを用いて考察する．

## 5.1 スタックマシン方式の評価と課題

### 5.1.1 メモリアクセス頻度の分析
本コンパイラは，演算の途中経過や変数の値を逐一スタックに退避する「スタックマシン」方式を採用している．この方式のオーバーヘッドを評価するため，「1から10までの和」を計算するプログラム（`sum.c`）の生成コードを分析した．

その結果，総命令数 70行（静的ステップ数）のうち，`sw`（ストア）および `lw`（ロード）命令は合計 19行であり，全命令の約 **27\%** がメモリアクセス命令で占められていることが判明した．
一般的なRISCアーキテクチャにおいて，メモリアクセスはレジスタ間演算に比べてレイテンシが大きく，パイプラインハザードの原因にもなりやすい．命令数の約3割がメモリアクセスであるという事実は，実行性能において看過できないボトルネックとなっている．

### 5.1.2 レジスタ割り当てによる最適化の実験
スタックマシン方式の課題を実証するため，`codegen.c` を一時的に改造し，特定の変数（`i` と `sum`）を強制的にレジスタ（`$t0`, `$t1`）に割り当てる実験を行った．
この最適化を行ったコンパイラで `sum.c` を再コンパイルした結果，以下の改善が見られた．

| 項目 | オリジナル (Stack) | 最適化実験版 (Reg) | 改善率 |
| :--- | :---: | :---: | :---: |
| **総実行命令数** | 347 cycles | 305 cycles | **約 12\% 減** |
| **`sw` 命令実行回数** | 19回 | 5回 | **約 74\% 減** |

変数の読み書きをレジスタ化しただけで，ストア命令の実行回数は劇的に減少し，プログラム全体の実行ステップ数も1割以上削減された．
今回は演算の途中経過（Push/Pop）までは最適化していないため，もしそれらも含めてフルにレジスタを利用すれば，さらに大幅な性能向上が見込める．
この実験より，実用的なコンパイラにおいては，スタックマシン方式から脱却し，グラフ彩色アルゴリズム等を用いた適切なレジスタ割り当て（Register Allocation）を実装することが不可欠であると結論付けられる．

## 5.2 AST設計と拡張性

### 5.2.1 2次元配列の実装とAST
本実験において，2次元配列（`array[i][j]`）の実装がスムーズに進んだ要因は，構文解析（Parser）段階でのAST設計にある．
`ARRAY_DECL_STATEMENT_AST` ノードに配列の次元情報（行数・列数）を保持させる設計としたことで，コード生成フェーズにおいてシンボルテーブルに必要な情報（`cols`）を確実に渡すことができた．
もしASTに必要な情報が含まれていなければ，コード生成中に情報を補完する複雑な処理（バックパッチなど）が必要となり，実装難易度は格段に上がっていたはずである．「後のフェーズで必要となる情報は，全てASTに残す」という原則の重要性を再認識した．

## 5.3 MIPSアーキテクチャへの適応

### 5.3.1 遅延分岐スロットの対処
MIPS特有の遅延分岐（Delay Slot）に対し，本実装では一律 `nop` を挿入する安全策をとった．
`FizzBuzz` プログラムの実行結果（3077命令）を見ると，その相当数が `nop` であると推測される．
商用コンパイラでは，このスロットに「分岐の直前の命令」や「分岐先でも分岐しなくても無害な命令」を移動させる「遅延スロット・スケジューリング」が行われる．
本コンパイラでも，単純な `nop` 挿入ではなく，直前の計算命令をスロットに移動させる最適化を実装すれば，命令数をさらに数\%〜10\%程度削減できる余地があると考えられる．
