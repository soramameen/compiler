## 4.3 変数と配列のメモリ管理

本コンパイラでは、変数の有効範囲（スコープ）やメモリ配置を管理するためにシンボルテーブルを用い、ベースアドレス方式によるメモリアクセスを実現している。

### 4.3.1 フレームポインタ($fp)による変数の基準化

変数のアクセスにおいて、本実装ではスタックポインタ（`$sp`）ではなくフレームポインタ（`$fp`）を基準アドレスとして採用した（例：`lw $v0, -4($fp)`）。

スタックポインタ（`$sp`）は、式の評価に伴う `push` / `pop` 操作によって関数実行中に頻繁に変動する。もし `$sp` を基準に変数を参照しようとすると、「今スタックにいくつ積まれているか」を常に追跡し、オフセットを動的に補正する必要が生じ、コンパイラの実装が極めて複雑になる。
対して、フレームポインタ（`$fp`）は関数の開始時点（プロローグ）で値を固定でき、その関数が終了するまで不変である。これにより、各変数のアドレスを「`$fp` からの固定オフセット」として静的に決定することが可能となり、安定した変数アクセスを実現した。なお、今回は単一の `main` 関数のみを対象としているため、実質的に `$fp` はプログラム全体の静的領域のベースとして機能している。

### 4.3.2 2次元配列のアドレス計算とシンボルテーブル

配列、特に2次元配列 `arr[i][j]` の実装においては、メモリ上のリニア（1次元）な空間に行優先（Row-Major）でデータを配置する方式をとった。個別の要素にアクセスするためには、以下の式でバイトオフセットを算出する必要がある。

$$ \text{Address} = \text{Base} + (i \times \text{cols} + j) \times 4 $$

この計算を動的に行うためには、配列の「列数（`cols`）」の情報が不可欠である。そこで、配列宣言（`ARRAY_DECL_STATEMENT_AST`）を処理する際に、シンボルテーブルに配列名だけでなくその `cols` の値もメタデータとして記録する設計とした。
コード生成時（`ARRAY_ACCESS_AST`）には、シンボルテーブルからこの `cols` を引き出し、MIPSの `mult`（乗算）や `mflo` 命令を用いて上記のアドレス計算式をアセンブリコードとして展開している。これにより、動的なインデックス `i`, `j` に対しても正しいメモリアクセスが可能となった。

### 4.R.3 2パス処理による静的領域の確保

本コンパイラの `generate_code` 関数では、実際のコード生成（`walk_ast`）を行う前に、一度 `find_declarations` 関数でAST全体を走査し、全ての変数宣言をシンボルテーブルに登録する前処理を行っている。

これは一種の「2パス」処理である。関数の先頭（プロローグ）で `addiu $sp, $sp, -frame_size` を実行して必要なメモリ領域を一括確保するためには、その関数内で使用される変数の総サイズをあらかじめ知っておく必要があるからだ。
「変数は静的に配置されるべき」という基本原則に従い、最初に全ての変数を洗い出してメモリレイアウトを確定させ、その後に実際の命令生成を行うという順序で処理を行うことで、メモリ管理の整合性を保っている。
