# 4. コード生成

本コンパイラにおけるコード生成（Code Generation）の設計と実装について述べる．
コード生成部は，構文解析によって生成された抽象構文木（AST）を入力とし，それを再帰的に走査（トラバース）することでMIPSアセンブリ命令を出力する．

## 4.1 コード生成の全体戦略

コード生成の中心となるのは `walk_ast` 関数である．この関数はASTのルートノードから深さ優先探索を行い，ノードの型（`NType`）に応じたアセンブリ命令を生成する．

MIPSアーキテクチャはレジスタマシンであるが，本実装ではコンパイラの構造を単純化するため，式評価において**スタックマシン**的なアプローチを採用した．
具体的には，演算の途中結果を一時的にスタックに退避（push）し，必要な時に取り出す（pop）ことで，レジスタ割り当ての複雑さを回避している．
基本的な演算の流れは以下の通りである．

1. 左側の部分木を評価する（結果は `$v0` レジスタに入る）．
2. `$v0` の値をスタックに push する．
3. 右側の部分木を評価する（結果は `$v0` レジスタに入る）．
4. スタックから値を pop し，`$v1` レジスタに入れる（これが左側の値となる）．
5. `$v1` と `$v0` で演算を行い，結果を `$v0` に格納する．

## 4.2 メモリ管理とスタックフレーム

変数のメモリ領域は，関数のスタックフレーム内に確保される．
本コンパイラでは，すべてのローカル変数をフレームポインタ（`$fp`）からの負のオフセット位置に配置している．

### 変数の配置
シンボルテーブル（`symbol_table.c`）において，各変数の相対アドレスを管理している．変数が宣言されるたびに，オフセット値は以下のように更新される．

- スカラー変数（`int`）: 4バイト消費
- 配列変数: `要素数 × 4` バイト消費

例えば，`define a; define b;` と宣言された場合，メモリレイアウトは以下のようになる．

- `$fp - 4`: 変数 `a`
- `$fp - 8`: 変数 `b`

### 関数プロローグとエピローグ
`main` 関数の開始時（プロローグ）では，以下の処理を行っている．

1. 必要なスタックサイズ（全変数のサイズ + レジスタ退避用）を計算する．
2. スタックポインタ `$sp` を減算し，領域を確保する．
3. 戻りアドレスレジスタ `$ra` と，古いフレームポインタ `$fp` をスタックに保存する．
4. 現在の `$sp` の値を新しい `$fp` として設定する．

終了時（エピローグ）では，これと逆の操作を行い，呼び出し元に復帰する．

## 4.3 レジスタの使い方

MIPSの汎用レジスタを，本コンパイラでは以下のような役割で固定的に使用している．

| レジスタ | 役割 |
| :--- | :--- |
| `$v0` | 式の評価結果，関数の戻り値，即値のロード先 |
| `$v1` | 二項演算における左オペランド（スタックからpopした値） |
| `$a0` | `print` システムコール（syscall）の引数 |
| `$t0` - `$t3` | アドレス計算や比較演算時の一時的な作業領域 |
| `$fp` ($30) | フレームポインタ（ローカル変数アクセスの基準） |
| `$sp` ($29) | スタックポインタ |
| `$ra` ($31) | 戻り番地 |

特に `$v0` は「現在の計算結果」を常に保持するアキュムレータのような役割を果たしている．また，バグ修正の過程で，システムコール実行時には `$v0` ではなく `$a0` に引数をセットする必要があることを学んだ．

## 4.4 算術式・比較演算のコード生成

### 算術演算
加算（`PLUS_AST`）を例に挙げると，以下のようなコードが生成される．

```assembly
# 左辺の評価（再帰呼び出し）
...
# 左辺の結果($v0)をpush
sw $v0, -4($sp)
addi $sp, $sp, -4

# 右辺の評価（再帰呼び出し）
...
# 左辺の結果をpopして$v1へ
lw $v1, 0($sp)
addi $sp, $sp, 4

# 加算
add $v0, $v0, $v1
```

### 比較演算
比較演算（`EQ`, `LT` など）も同様にスタックを利用するが，MIPSの `slt` (Set on Less Than) 命令などを組み合わせて実装した．
例えば `a <= b` (`LE_AST`) の場合，MIPSには `sle` 命令が存在しないため，「`b < a` の否定」または「`!(a > b)`」として論理を組み立てる必要がある．本実装では `slt` と `xori`（排他的論理和による反転）を組み合わせて実現した．

## 4.5 制御構造

### If文 / While文
`IF_AST` や `WHILE_AST` では，一意なラベル番号（`current_label_num`）を生成し，条件分岐命令（`beq`）とジャンプ命令（`j`）を組み合わせている．

MIPS特有の**遅延分岐スロット**（Branch Delay Slot）に関しては，分岐命令の直後に `nop` 命令を挿入することで，意図しない命令が実行されるのを防ぐ安全策をとった．

## 4.6 配列の実装（特に工夫した点）

本課題において特に工夫したのは，**1次元配列および2次元配列のサポート**である．

### メモリ配置
配列宣言 `define arr[10];` があると，シンボルテーブルに配列として登録され，スタック上に `10 * 4 = 40` バイトの連続領域が確保される．
2次元配列 `define mat[3][4];` の場合も同様に，`3 * 4 = 12` 個の要素を持つ1次元配列としてメモリ上にフラットに配置される（行優先順序）．

### アドレス計算
配列参照 `arr[i]` や `mat[i][j]` のコード生成では，実行時にインデックス計算を行うコードを出力する．

**1次元配列の場合**:
ベースアドレス（`$fp` からのオフセット）に対し，インデックスの4倍（`sll $v0, $v0, 2`）を加算してアドレスを求める．

**2次元配列の場合**:
`mat[i][j]` のアクセスにおいて，列数（`cols`）を用いて以下の式でオフセットを計算する．

\[ \text{offset} = (i \times \text{cols} + j) \times 4 \]

MIPSには乗算命令 `mul` があるが，あえて `mult` 命令と `mflo` 命令を使用することで，より基本的な命令セットでの実装を行った．

```assembly
# 行インデックス i を $t0 へ
...
# 列インデックス j を $t1 へ
...
# 列数 cols をロード
li $t2, 4
# i * cols
mult $t0, $t2
mflo $t3
# (i * cols) + j
add $t3, $t3, $t1
# バイトオフセットへ変換 (* 4)
sll $t3, $t3, 2
```

このように，2次元配列をサポートすることで，行列演算などのより高度なプログラムを記述可能にした．
