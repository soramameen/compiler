`num`（数値）や `ident`（識別子）の値を `print_tree` で表示するための実装案を、推奨順にランキング形式で提示します。

現在のコードはJSON風の出力を目指しているため、JSONの構文規則を維持しつつ情報を付加する方法を優先します。

---

### ランキング

#### 1位：プロパティ追加型（推奨）
ノードオブジェクトの中に `"value": ...` というフィールドを追加する方法です。
*   **メリット:** データ（値）とメタデータ（型・ID）が分離されており、JSONパーサ等で機械的に扱いやすい。構造が一貫する。
*   **デメリット:** 出力サイズが少し増える。JSONのカンマ制御に少し気を使う必要がある。

#### 2位：キー埋め込み型（デバッグ用）
キー名に値を埋め込む方法（例: `"NUMBER_AST_10_0": {}`）。
*   **メリット:** 実装が最も簡単。ツリー構造の概観を見る際、キーを見るだけで値がわかる。
*   **デメリット:** キーが動的になりすぎるため、後でプログラムから参照・検索しにくい。値が長い文字列の場合、キーが非常に長くなる。

#### 3位：リーフ（葉）簡略化型
`NUMBER` や `IDENT` の場合は `{}` を作らず、直接値を出力する（例: `"NUMBER_AST_0": 10`）。
*   **メリット:** 出力が非常にコンパクトになる。
*   **デメリット:** 現在の再帰ロジック（`brother` の処理など）を分岐させる必要があり、コードが複雑になる。一貫性が崩れる。

---

### 推奨実装（1位：プロパティ追加型）

`print_tree` 関数を以下のように修正します。`NUMBER_AST` や `IDENT_AST` の場合に値を先に出力し、その後で子供の再帰を行います。

```c
int print_tree(Node *n, int num){
    // ノードタイプの定義と列挙型の値が一致している前提です
    // #include "ast.h" で定義されているはずの定数を使用

    printf("\"%s_%d\": {", node_types[n->type], num++);

    // --- 追加部分: 値の出力 ---
    if (n->type == NUMBER_AST) { // 2 or 定数マクロ
        printf("\"value\": %d", n->val.ival);
        // 子供がいる場合はカンマが必要だが、通常Numberは葉ノード
        if (n->child != NULL) printf(", "); 
    }
    else if (n->type == IDENT_AST) { // 0 or 定数マクロ
        printf("\"value\": \"%s\"", n->val.sval);
        if (n->child != NULL) printf(", ");
    }
    // -----------------------

    if (n->child != NULL) {
        num = print_tree(n->child, num);
    }
    printf("}");
    
    if(n->brother != NULL) {
        printf(",");
        num = print_tree(n->brother, num);
    }
    return num;
}
```

**補足:**
`ast.h` 内で `NUMBER_AST`, `IDENT_AST` がどの `int` 値にマッピングされているか確認してください（配列 `node_types` のインデックスと一致させる必要があります）。

*   `IDENT_AST` は配列の `0` 番目なら `type == 0`
*   `NUMBER_AST` は配列の `2` 番目（または `9` 番目? 重複しています）なら `type == 2`

コード内の `node_types` 配列で `NUMBER_AST` が重複定義（インデックス2と9）されているように見えますので、ヘッダー定義と一致するよう整理することをお勧めします。

