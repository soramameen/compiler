提示されたコードに基づき、数値（`num_node`）と識別子（`ident_node`）を実装するための3つのアプローチを提案します。

根本的に、現在の`Node`構造体には**「値（数値や文字列）」を保存する場所がない**ため、構造体の定義（`ast.h`内と想定）を変更する必要があります。

---

### 実装案

#### 1. Union（共用体）を追加する方法（推奨）
`Node`構造体内に、値保持用の`union`を追加します。

*   **実装イメージ:**
    ```c
    // ast.h
    typedef struct Node {
        NType type;
        struct Node *child;
        struct Node *brother;
        union {
            int ival;    // 数値用
            char *sval;  // 識別子文字列用
        } val;
    } Node;
    
    // 実装関数
    Node *build_num_node(int n) {
        Node *p = build_node0(NUMBER_AST);
        p->val.ival = n;
        return p;
    }
    Node *build_ident_node(char *s) {
        Node *p = build_node0(IDENTS_AST);
        p->val.sval = strdup(s); // 文字列をコピー
        return p;
    }
    ```
*   **メリット:**
    *   実装が最もシンプルで直感的。
    *   既存の`print_tree`関数等の修正が最小限で済む。
    *   型へのアクセスが容易。
*   **デメリット:**
    *   すべてのノードでメモリサイズが最大メンバー（ポインタ分）に固定されるため、若干のメモリ無駄が発生する（現代のPCでは誤差）。

#### 2. 構造体の拡張（疑似継承）を使う方法
基本の`Node`構造体を定義し、それを拡張した`NumNode`や`IdentNode`を作ります。

*   **実装イメージ:**
    ```c
    typedef struct NumNode {
        NType type;
        struct Node *child, *brother; // Baseと同じレイアウト
        int value;
    } NumNode;
    // 使用時に (Node*) にキャストして扱う
    ```
*   **メリット:**
    *   メモリ効率が良い（必要なノードにだけ値を確保）。
*   **デメリット:**
    *   C言語でのキャストが頻発し、コードが複雑になる。
    *   `print_tree`などで型に応じたキャスト処理が必要になり、バグを生みやすい。

#### 3. `void*` ポインタを使う方法
`Node`構造体に汎用ポインタを持たせます。

*   **実装イメージ:**
    ```c
    typedef struct Node {
        // ...既存フィールド
        void *data;
    } Node;
    ```
*   **メリット:**
    *   任意のデータ構造を後付けできる柔軟性。
*   **デメリット:**
    *   数値（int）を扱う際にポインタサイズへのキャストや`malloc`が必要で面倒。
    *   型安全性がない（デバッグが困難）。

---

### ランキング（推奨順）

1.  **【1位】 Union（共用体）を追加する方法**
    *   **理由:** コンパイラ作成の初学者から中級者にとって最も標準的で、バグが入りにくく管理しやすいため。提示されたコードの設計（シンプルなAST）に最も合致しています。

2.  **【2位】 構造体の拡張（疑似継承）**
    *   **理由:** メモリ効率は良いですが、ポインタのキャスト操作が増え、現在のコードベース（`build_node`系）を大幅に書き換える必要があるため、実装コストが高いです。

3.  **【3位】 `void*` ポインタ**
    *   **理由:** `int`をポインタとして扱うか、`int`のためにわざわざ`malloc`する必要があり、コードが汚くなりやすいため推奨しません。

